import{useCallback as y,useEffect as w,useState as L}from"react";import{createContext as S,useContext as _}from"react";function b(){return _(E)}var E=S({listeners:new Set,stateMap:new Map});var f={api:{hostname:"api.lanyard.rest",secure:!0}};function g(a,n){return`${n.api.secure?"https":"http"}://${n.api.hostname}/v1/users/${a}`}async function x(a,n){let o={method:"GET",signal:n.controller?.signal??null,headers:{Accept:"application/json"}},l=new Request(a,o),e=await fetch(l),i=await e.json();return i.success?{success:!0,data:i.data}:{success:!1,error:new m(l,e,i)}}var m=class extends Error{constructor(o,l,e){super(e.error.message);this.request=o;this.response=l;this.body=e;this.code=this.response.status}code};function q(a,n){let o={...f,...n},[,l]=L({}),e=b();e.stateMap.has(a)||e.stateMap.set(a,{state:"initial",isLoading:!1,data:o.initialData,error:void 0});let i=r=>{e.stateMap.set(a,r);for(let s of e.listeners)s()},c=()=>{let r=e.stateMap.get(a);if(!r)throw new Error("State not found");return r},p=r=>{i({...c(),isLoading:r})},d=g(a,o),t=y(async r=>{if(c().isLoading)return;p(!0);let s=await x(d,r?{...o,controller:r}:o);s.error?i({...c(),state:"errored",error:s.error,isLoading:!1}):i({...c(),state:"loaded",data:s.data,isLoading:!1})},[d]);return w(()=>{let r=()=>l({});e.listeners.add(r);let s=new AbortController;return t().finally(()=>{p(!1)}),()=>{s.abort(),e.listeners.delete(r)}},[t]),{...c(),revalidate:y(()=>t(),[t])}}import{useEffect as v,useState as D}from"react";var k=(e=>(e[e.Event=0]="Event",e[e.Hello=1]="Hello",e[e.Initialize=2]="Initialize",e[e.Heartbeat=3]="Heartbeat",e))(k||{}),A=(o=>(o.INIT_STATE="INIT_STATE",o.PRESENCE_UPDATE="PRESENCE_UPDATE",o))(A||{});function K(a,n){let o={...f,...n},[l,e]=D(),c=`${o.api.secure?"wss":"ws"}://${o.api.hostname}/socket`;return v(()=>{if(typeof window>"u")return;if(!("WebSocket"in window||"MozWebSocket"in window))throw new Error("WebSocket connections not supported in this browser.");let p;typeof a=="object"?p={subscribe_to_ids:a}:p={subscribe_to_id:a};let d,t;function r(){d&&clearInterval(d),t=new WebSocket(c),t.addEventListener("open",()=>{console.log("Lanyard: Socket connection opened")}),t.addEventListener("close",r),t.addEventListener("message",s=>{let u=JSON.parse(s.data);switch(u.op){case 1:{d=setInterval(()=>{t.readyState===t.OPEN&&t.send(JSON.stringify({op:3}))},u.d?.heartbeat_interval),t.readyState===t.OPEN&&t.send(JSON.stringify({op:2,d:p}));break}case 0:{switch(u.t){case"INIT_STATE":case"PRESENCE_UPDATE":{u.d&&e(u.d);break}default:break}break}default:break}})}return r(),()=>{clearInterval(d),t.removeEventListener("close",r),t.close()}},[c]),l??o.initialData}export{f as DEFAULT_OPTIONS,m as LanyardError,A as SocketEvents,k as SocketOpcode,x as get,g as getURL,q as useLanyard,K as useLanyardWS};
//# sourceMappingURL=index.mjs.map